#!/usr/bin/env python3
# Copyright 2025
#
# This code was generated by the openapi-spec-tools CLI generator, DO NOT EDIT
#

from datetime import date  # noqa: F401
from datetime import datetime  # noqa: F401
from enum import Enum  # noqa: F401
from pathlib import Path
from typing import Annotated  # noqa: F401
from typing import Optional  # noqa: F401

import typer

from cloudtruth_gen_cli import _arguments as _a
from cloudtruth_gen_cli import _display as _d  # noqa: F401
from cloudtruth_gen_cli import _exceptions as _e  # noqa: F401
from cloudtruth_gen_cli import _logging as _l  # noqa: F401
from cloudtruth_gen_cli import _requests as _r  # noqa: F401
from cloudtruth_gen_cli import _tree as _t


app = typer.Typer(no_args_is_help=True, help="Manage CloudTruth grants")

@app.command("commands", short_help="Display commands tree for sub-commands")
def show_commands(
    display: _a.TreeDisplayOption = _a.TreeDisplay.HELP,
    depth: _a.MaxDepthOption = 5,
) -> None:
    path = Path(__file__).parent / "tree.yaml"
    _t.tree(path.as_posix(), "grants", display, depth)
    return


class RoleEnum(str, Enum):  # noqa: F811
    OWNER = "OWNER"
    ADMIN = "ADMIN"
    CONTRIB = "CONTRIB"
    VIEWER = "VIEWER"


@app.command("create", short_help="Grants allow you to enable access control on Environments and Projects.")
def grants_create(
    principal: Annotated[str, typer.Option(show_default=False, help="The URI of a principal for the grant; this must reference a user or group.")] = None,
    scope: Annotated[str, typer.Option(show_default=False, help="The URI of a scope for the grant; this must reference a project or environment.")] = None,
    role: Annotated[RoleEnum, typer.Option(show_default=False, case_sensitive=False, help="The role that the principal has in the given scope.")] = None,
    _api_host: _a.ApiHostOption = "",
    _api_key: _a.ApiKeyOption = None,
    _api_timeout: _a.ApiTimeoutOption = 5,
    _log_level: _a.LogLevelOption = _a.LogLevel.WARN,
    _out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE,
    _out_style: _a.OutputStyleOption = _a.OutputStyle.ALL,
) -> None:
    '''
    Grants allow you to enable access control on Environments and Projects.

    Grants are part of the role-based access control feature set, so
    if your subscription does not have support for it, these paths
    will return a 403 Forbidden error.
    '''
    # handler for grants_create: POST /api/v1/grants/
    _l.init_logging(_log_level)
    headers = _r.request_headers(_api_key, content_type="application/json")
    url = _r.create_url(_api_host, "api/v1/grants/")
    missing = []
    if _api_key is None:
        missing.append("--api-key")
    if principal is None:
        missing.append("--principal")
    if scope is None:
        missing.append("--scope")
    if role is None:
        missing.append("--role")
    if missing:
        _e.handle_exceptions(_e.MissingRequiredError(missing))

    params = {}
    body = {}
    body["principal"] = principal
    body["scope"] = scope
    body["role"] = role

    try:
        data = _r.request("POST", url, headers=headers, params=params, body=body, timemout=_api_timeout)
        _d.display(data, _out_fmt, _out_style)
    except Exception as ex:
        _e.handle_exceptions(ex)

    return


@app.command("delete", short_help="Grants allow you to enable access control on Environments and Projects.")
def grants_destroy(
    id: Annotated[str, typer.Argument(show_default=False, help="A unique identifier for the grant.")],
    _api_host: _a.ApiHostOption = "",
    _api_key: _a.ApiKeyOption = None,
    _api_timeout: _a.ApiTimeoutOption = 5,
    _log_level: _a.LogLevelOption = _a.LogLevel.WARN,
    _out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE,
    _out_style: _a.OutputStyleOption = _a.OutputStyle.ALL,
) -> None:
    '''
    Grants allow you to enable access control on Environments and Projects.

    Grants are part of the role-based access control feature set, so
    if your subscription does not have support for it, these paths
    will return a 403 Forbidden error.
    '''
    # handler for grants_destroy: DELETE /api/v1/grants/{id}/
    _l.init_logging(_log_level)
    headers = _r.request_headers(_api_key)
    url = _r.create_url(_api_host, "api/v1/grants", id)
    missing = []
    if _api_key is None:
        missing.append("--api-key")
    if missing:
        _e.handle_exceptions(_e.MissingRequiredError(missing))

    params = {}

    try:
        data = _r.request("DELETE", url, headers=headers, params=params, timemout=_api_timeout)
        _d.display(data, _out_fmt, _out_style)
    except Exception as ex:
        _e.handle_exceptions(ex)

    return


@app.command("delete-many", short_help="Removes grants matching the query parameters atomically.")
def grants_multi_destroy(
    _api_host: _a.ApiHostOption = "",
    _api_key: _a.ApiKeyOption = None,
    _api_timeout: _a.ApiTimeoutOption = 5,
    _log_level: _a.LogLevelOption = _a.LogLevel.WARN,
    _out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE,
    _out_style: _a.OutputStyleOption = _a.OutputStyle.ALL,
) -> None:
    '''
    Removes grants matching the query parameters atomically.

    Use this technique to disable access control on a scope,
    or remove all grants for a user.
    '''
    # handler for grants_multi_destroy: DELETE /api/v1/grants/multi/
    _l.init_logging(_log_level)
    headers = _r.request_headers(_api_key)
    url = _r.create_url(_api_host, "api/v1/grants/multi/")
    missing = []
    if _api_key is None:
        missing.append("--api-key")
    if missing:
        _e.handle_exceptions(_e.MissingRequiredError(missing))

    params = {}

    try:
        data = _r.request("DELETE", url, headers=headers, params=params, timemout=_api_timeout)
        _d.display(data, _out_fmt, _out_style)
    except Exception as ex:
        _e.handle_exceptions(ex)

    return


class Role(str, Enum):  # noqa: F811
    ADMIN = "ADMIN"
    CONTRIB = "CONTRIB"
    OWNER = "OWNER"
    VIEWER = "VIEWER"


@app.command("list", short_help="Grants allow you to enable access control on Environments and Projects.")
def grants_list(
    ordering: Annotated[Optional[str], typer.Option(show_default=False, help="Which field to use when ordering the results.")] = None,
    page: Annotated[Optional[int], typer.Option(show_default=False, help="A page number within the paginated result set.")] = None,
    page_size: Annotated[Optional[int], typer.Option(show_default=False, help="Number of results to return per page.")] = None,
    principal: Annotated[Optional[str], typer.Option(show_default=False, help="Filter by principal (User, Group). Returns direct grant assignments, not indirect (user via group).")] = None,
    role: Annotated[Optional[Role], typer.Option(show_default=False, case_sensitive=False, help="Filter by role.")] = None,
    scope: Annotated[Optional[str], typer.Option(show_default=False, help="Filter by grant scope (Environment, Project).")] = None,
    _api_host: _a.ApiHostOption = "",
    _api_key: _a.ApiKeyOption = None,
    _api_timeout: _a.ApiTimeoutOption = 5,
    _log_level: _a.LogLevelOption = _a.LogLevel.WARN,
    _out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE,
    _out_style: _a.OutputStyleOption = _a.OutputStyle.ALL,
    _max_count: _a.MaxCountOption = None,
) -> None:
    '''
    Grants allow you to enable access control on Environments and Projects.

    Grants are part of the role-based access control feature set, so
    if your subscription does not have support for it, these paths
    will return a 403 Forbidden error.
    '''
    # handler for grants_list: GET /api/v1/grants/
    _l.init_logging(_log_level)
    headers = _r.request_headers(_api_key)
    url = _r.create_url(_api_host, "api/v1/grants/")
    page_info = _r.PageParams(max_count=_max_count, page_size_name="page_size", page_size_value=page_size, page_start_name="page", page_start_value=page, item_property_name="result", next_property_name="next")
    missing = []
    if _api_key is None:
        missing.append("--api-key")
    if missing:
        _e.handle_exceptions(_e.MissingRequiredError(missing))

    params = {}
    if ordering is not None:
        params["ordering"] = ordering
    if page is not None:
        params["page"] = page
    if page_size is not None:
        params["page_size"] = page_size
    if principal is not None:
        params["principal"] = principal
    if role is not None:
        params["role"] = role
    if scope is not None:
        params["scope"] = scope

    try:
        data = _r.depaginate(page_info, url, headers=headers, params=params, timemout=_api_timeout)
        _d.display(data, _out_fmt, _out_style)
    except Exception as ex:
        _e.handle_exceptions(ex)

    return


class RoleEnum(str, Enum):  # noqa: F811
    OWNER = "OWNER"
    ADMIN = "ADMIN"
    CONTRIB = "CONTRIB"
    VIEWER = "VIEWER"


@app.command("set", short_help="Grants allow you to enable access control on Environments and Projects.")
def grants_update(
    id: Annotated[str, typer.Argument(show_default=False, help="A unique identifier for the grant.")],
    principal: Annotated[str, typer.Option(show_default=False, help="The URI of a principal for the grant; this must reference a user or group.")] = None,
    scope: Annotated[str, typer.Option(show_default=False, help="The URI of a scope for the grant; this must reference a project or environment.")] = None,
    role: Annotated[RoleEnum, typer.Option(show_default=False, case_sensitive=False, help="The role that the principal has in the given scope.")] = None,
    _api_host: _a.ApiHostOption = "",
    _api_key: _a.ApiKeyOption = None,
    _api_timeout: _a.ApiTimeoutOption = 5,
    _log_level: _a.LogLevelOption = _a.LogLevel.WARN,
    _out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE,
    _out_style: _a.OutputStyleOption = _a.OutputStyle.ALL,
) -> None:
    '''
    Grants allow you to enable access control on Environments and Projects.

    Grants are part of the role-based access control feature set, so
    if your subscription does not have support for it, these paths
    will return a 403 Forbidden error.
    '''
    # handler for grants_update: PUT /api/v1/grants/{id}/
    _l.init_logging(_log_level)
    headers = _r.request_headers(_api_key, content_type="application/json")
    url = _r.create_url(_api_host, "api/v1/grants", id)
    missing = []
    if _api_key is None:
        missing.append("--api-key")
    if principal is None:
        missing.append("--principal")
    if scope is None:
        missing.append("--scope")
    if role is None:
        missing.append("--role")
    if missing:
        _e.handle_exceptions(_e.MissingRequiredError(missing))

    params = {}
    body = {}
    body["principal"] = principal
    body["scope"] = scope
    body["role"] = role

    try:
        data = _r.request("PUT", url, headers=headers, params=params, body=body, timemout=_api_timeout)
        _d.display(data, _out_fmt, _out_style)
    except Exception as ex:
        _e.handle_exceptions(ex)

    return


@app.command("show", short_help="Grants allow you to enable access control on Environments and Projects.")
def grants_retrieve(
    id: Annotated[str, typer.Argument(show_default=False, help="A unique identifier for the grant.")],
    _api_host: _a.ApiHostOption = "",
    _api_key: _a.ApiKeyOption = None,
    _api_timeout: _a.ApiTimeoutOption = 5,
    _log_level: _a.LogLevelOption = _a.LogLevel.WARN,
    _out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE,
    _out_style: _a.OutputStyleOption = _a.OutputStyle.ALL,
) -> None:
    '''
    Grants allow you to enable access control on Environments and Projects.

    Grants are part of the role-based access control feature set, so
    if your subscription does not have support for it, these paths
    will return a 403 Forbidden error.
    '''
    # handler for grants_retrieve: GET /api/v1/grants/{id}/
    _l.init_logging(_log_level)
    headers = _r.request_headers(_api_key)
    url = _r.create_url(_api_host, "api/v1/grants", id)
    missing = []
    if _api_key is None:
        missing.append("--api-key")
    if missing:
        _e.handle_exceptions(_e.MissingRequiredError(missing))

    params = {}

    try:
        data = _r.request("GET", url, headers=headers, params=params, timemout=_api_timeout)
        _d.display(data, _out_fmt, _out_style)
    except Exception as ex:
        _e.handle_exceptions(ex)

    return


class RoleEnum(str, Enum):  # noqa: F811
    OWNER = "OWNER"
    ADMIN = "ADMIN"
    CONTRIB = "CONTRIB"
    VIEWER = "VIEWER"


@app.command("update", short_help="Grants allow you to enable access control on Environments and Projects.")
def grants_partial_update(
    id: Annotated[str, typer.Argument(show_default=False, help="A unique identifier for the grant.")],
    principal: Annotated[Optional[str], typer.Option(show_default=False, help="The URI of a principal for the grant; this must reference a user or group.")] = None,
    scope: Annotated[Optional[str], typer.Option(show_default=False, help="The URI of a scope for the grant; this must reference a project or environment.")] = None,
    role: Annotated[Optional[RoleEnum], typer.Option(show_default=False, case_sensitive=False, help="The role that the principal has in the given scope.")] = None,
    _api_host: _a.ApiHostOption = "",
    _api_key: _a.ApiKeyOption = None,
    _api_timeout: _a.ApiTimeoutOption = 5,
    _log_level: _a.LogLevelOption = _a.LogLevel.WARN,
    _out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE,
    _out_style: _a.OutputStyleOption = _a.OutputStyle.ALL,
) -> None:
    '''
    Grants allow you to enable access control on Environments and Projects.

    Grants are part of the role-based access control feature set, so
    if your subscription does not have support for it, these paths
    will return a 403 Forbidden error.
    '''
    # handler for grants_partial_update: PATCH /api/v1/grants/{id}/
    _l.init_logging(_log_level)
    headers = _r.request_headers(_api_key, content_type="application/json")
    url = _r.create_url(_api_host, "api/v1/grants", id)
    missing = []
    if _api_key is None:
        missing.append("--api-key")
    if missing:
        _e.handle_exceptions(_e.MissingRequiredError(missing))

    params = {}
    body = {}
    if principal is not None:
        body["principal"] = principal
    if scope is not None:
        body["scope"] = scope
    if role is not None:
        body["role"] = role

    try:
        data = _r.request("PATCH", url, headers=headers, params=params, body=body, timemout=_api_timeout)
        _d.display(data, _out_fmt, _out_style)
    except Exception as ex:
        _e.handle_exceptions(ex)

    return


if __name__ == "__main__":
    app()
